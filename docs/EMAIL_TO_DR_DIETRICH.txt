================================================================================
EMAIL TO DR. DIETRICH - PROJECT OVERVIEW
================================================================================

Subject: Bytecode Analysis Demo Repository - As Discussed

Hi Dr. Dietrich,

As mentioned in my previous email, I've created a public demo repository that 
demonstrates the core ideas we discussed:

Repository: https://github.com/Aashish792/bytecode-analysis-tools

================================================================================
WHAT THIS TOOL DOES
================================================================================

This is a research-grade bytecode analysis tool with TWO main capabilities:

1. JAR DEPENDENCY ANALYSIS
   - Finds which methods in one JAR call methods in another JAR
   - Uses ASM library for bytecode analysis (same as in your paper)
   - Detects all 5 JVM invoke types (virtual, static, special, interface, dynamic)

2. BUILD VARIABILITY ANALYSIS (DIFF/EXPLAIN)
   - Compares two JARs built from the same source
   - Explains WHY they differ (JDK version, bytecode, debug info)
   - Detects JDK version mismatches that cause runtime failures
   - Provides actionable recommendations (use -release flag)

================================================================================
KEY FEATURE: REFLECTION-AWARE ANALYSIS
================================================================================

As I mentioned in my email, static analysis cannot see dependencies loaded via
reflection. This tool addresses that limitation by detecting:

  • Class.forName() - Dynamic class loading
  • getMethod() / getDeclaredMethod() - Method lookup by name  
  • Method.invoke() - Reflective invocation
  • Constructor.newInstance() - Reflective object creation

When possible, I capture the TARGET class/method name by tracking LDC 
instructions that precede reflection calls. This provides visibility into
otherwise hidden dependencies.

Example output:
  ⚠️ Reflective Calls Detected (12):
    CLASS_FOR_NAME in ClassUtil.findClass → target: "BeanSerializer"
    METHOD_INVOKE in Invoker.call → target: unknown

================================================================================
HOW THIS DIFFERS FROM MY PREVIOUS JAR-CALL-ANALYZER
================================================================================

I have another repository called "jar-call-analyzer" which is a simpler tool.
Here's how they compare:

┌─────────────────────────┬────────────────────┬─────────────────────────────┐
│ Feature                 │ jar-call-analyzer  │ bytecode-analysis-tools     │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Basic dependency        │ ✅ Yes             │ ✅ Yes                      │
│ analysis                │                    │                             │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Reflection detection    │ ❌ No              │ ✅ Yes - 6 patterns with    │
│ (Class.forName, etc.)   │                    │    LDC target extraction    │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Build diff/explain      │ ❌ No              │ ✅ Yes - explains WHY       │
│                         │                    │    builds differ            │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ JDK mismatch detection  │ ❌ No              │ ✅ Yes - warns about        │
│                         │                    │    -target vs -release      │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Standalone reflection   │ ❌ No              │ ✅ Yes - scan single JAR    │
│ scanner                 │                    │                             │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Common scenarios guide  │ ❌ No              │ ✅ Yes - 8 documented       │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Web UI                  │ ✅ Basic           │ ✅ Professional sidebar UI  │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Unit tests              │ ✅ Basic           │ ✅ 30+ comprehensive tests  │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Research connection     │ ❌ No              │ ✅ Yes - ICST 2025 paper    │
├─────────────────────────┼────────────────────┼─────────────────────────────┤
│ Architecture            │ Basic layers       │ Clean Architecture, SOLID, │
│                         │                    │ immutable models, DI        │
└─────────────────────────┴────────────────────┴─────────────────────────────┘

SUMMARY:
- jar-call-analyzer = Simple proof-of-concept
- bytecode-analysis-tools = Research-grade tool matching what we discussed

================================================================================
ARCHITECTURE HIGHLIGHTS
================================================================================

The code follows Clean Architecture and SOLID principles:

1. SINGLE RESPONSIBILITY
   - Extractors only extract (AsmMethodDefinitionExtractor, AsmMethodCallExtractor)
   - Analyzers only orchestrate (JarDependencyAnalyzer, BuildDiffAnalyzer)
   - Models only hold data (MethodSignature, MethodCall, AnalysisResult)

2. INTERFACE SEGREGATION
   - MethodDefinitionExtractor: extracts method definitions
   - MethodCallExtractor: extracts method calls + reflection

3. DEPENDENCY INVERSION
   - Analyzers depend on interfaces, not ASM directly
   - Enables easy testing with mock implementations

4. IMMUTABILITY
   - All models use Java Records or are immutable
   - Collections are wrapped in unmodifiableSet/List

================================================================================
TEST SUITE
================================================================================

30+ unit tests covering:
- Model classes (MethodSignature, MethodCall, InvokeType)
- Analysis results (coverage calculation, reflection warnings)
- Diff results (JDK mismatch detection, recommendations)
- Integration (error handling, dependency injection)

Run with: mvn test

================================================================================
HOW TO TEST
================================================================================

1. Clone and build:
   git clone https://github.com/Aashish792/bytecode-analysis-tools.git
   cd bytecode-analysis-tools
   mvn clean package

2. Run:
   java -jar target/bytecode-analysis-tools-1.0.0.jar

3. Open browser:
   http://localhost:8080

4. Test with Jackson JARs:
   wget https://repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.15.0/jackson-databind-2.15.0.jar
   wget https://repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.15.0/jackson-core-2.15.0.jar

   Expected results:
   - databind → core: ~275 calls
   - core → databind: 0 calls
   - 12 reflection warnings

================================================================================
ADDITIONAL SCENARIOS HANDLED
================================================================================

Beyond basic dependency analysis, this tool addresses several scenarios that 
can arise during bytecode analysis:

1. JDK VERSION MISMATCH
   - Detects when builds use different JDK versions
   - Warns about ByteBuffer.flip() covariant return type issue
   - Recommends -release flag instead of -target

2. COVARIANT RETURN TYPES  
   - Java compilers generate bridge methods for covariant returns
   - Different JDKs generate different call signatures
   - Tool detects these differences in build comparison

3. HIDDEN REFLECTION DEPENDENCIES
   - Class.forName() dynamically loads classes
   - Method.invoke() calls methods invisibly
   - Tool tracks LDC instructions to capture target names when possible

4. DEBUG INFO VARIANCE
   - Line numbers and local variable tables differ between builds
   - Harmless for execution but causes hash mismatches
   - Tool identifies this as a reason for differences

5. TIMESTAMP EMBEDDING
   - Build timestamps cause non-reproducible builds
   - Tool extracts manifest metadata to show this

6. LAMBDA/INVOKEDYNAMIC DIFFERENCES
   - Lambda ordering may vary between compilations
   - Tool detects all INVOKEDYNAMIC instructions

7. -target vs -release FLAG ISSUE
   - Using -target 8 with JDK 11 still uses JDK 11's stdlib
   - Tool warns and recommends -release flag (JEP 247)

8. CONSTANT POOL ORDERING
   - Parallel compilation produces different orderings
   - Tool explains this as a harmless difference

================================================================================
CONNECTION TO YOUR RESEARCH
================================================================================

This tool directly relates to your ICST 2025 paper findings:

1. The build diff feature detects JDK version mismatches (like the 
   undertow-servlet issue where Maven Central used JDK 8 but GAOSS used JDK 11)

2. It recommends using -release flag instead of -target (JEP 247)

3. The reflection detection addresses a limitation of static analysis that
   could affect the completeness of dependency graphs

================================================================================

I'm genuinely excited about this research direction and looking forward to 
potentially working with you. Please let me know if you'd like me to explain
any aspect in more detail or if there are specific features you'd like to see.

Best regards,
Aashish K C
asiskc143@gmail.com
https://github.com/Aashish792

================================================================================
